---
title: 'Sign-In with Ethereum'
description: 'Learn how to use the SIWE authentication standard with wagmi.'
---

import { Callout } from 'nextra-theme-docs'

import { SSX } from '../../components/examples'

# Sign-In with Ethereum

[Sign-In with Ethereum](https://login.xyz) is an authentication standard ([EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361)) that enables secure communication between a frontend and backend. SIWE is a powerful method for creating user sessions based on a wallet connection, and much more! It's simple to add SIWE to both your frontend client app and your backend server with minimal configuration with [SSX](https://docs.ssx.id) library.

<SSX />

Pretty cool, right?! You can refresh the window or disconnect your wallet, and you are still securely logged in.

## Overview

Implementing SIWE only takes four steps:

1. Connect wallet
2. Sign SIWE message with nonce generated by backend (all built-in in the `signIn` function)
3. Verify submitted SIWE message and signature via POST request (also built-in in the `login` function of the server)
4. Add validated SIWE fields to session (via JWT, cookie, etc.)

<Callout type="info">
  This guide uses Next.js [API
  Routes](https://nextjs.org/docs/api-routes/introduction) for the backend and
  [`iron-session`](https://github.com/vvo/iron-session) to secure the user
  session, but you can also use other backend frameworks and storage methods.
</Callout>

## Prerequisites

Install [`@spruceid/ssx`](https://www.npmjs.com/package/@spruceid/ssx), [`@spruceid/ssx-server`](https://www.npmjs.com/package/@spruceid/ssx-server) and [`iron-session`](https://github.com/vvo/iron-session) with your package manager of choice:

```plaintext
npm install @spruceid/ssx @spruceid/ssx-server iron-session
```

<details>
  <summary>`iron-session`&nbsp;&nbsp;TypeScript Set Up</summary>
In order for TypeScript to work properly with `iron-session` and `ssx`, you need to add a couple properties to the `IronSessionData` interface. Add the following to `types/iron-session/index.d.ts`.

```ts filename="types/iron-session/index.d.ts"
import 'iron-session'
import { SiweMessage } from '@spruceid/ssx'

declare module 'iron-session' {
  interface IronSessionData {
    nonce?: string
    siwe?: SiweMessage
  }
}
```

Then, update your `tsconfig.json` to include the custom types directory:

```diff filename="tsconfig.json"
{
  "compilerOptions": {
    // ...
  },
-  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
+  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", "types/**/*.d.ts"],
  "exclude": ["node_modules"]
}
```

</details>

## Step 1: Connect Wallet

Follow the [Connect Wallet](/examples/connect-wallet#step-1-configuring-connectors) guide to get this set up.

## Step 2: Add API routes

<Callout type="info">
  If you are using an ExpressJS API you can simply use `SSXExpressMiddleware`
  from SSX Server and all the routes will be automatically created. For more
  information checkout [this
  example](https://www.github.com/spruceid/ssx/tree/main/examples/ssx-quickstart-express).
</Callout>

First let's start by adding a helper file so that we don't have to directly instantiate a new SSX Server object everytime.

```ts filename="pages/api/_ssx.ts"
import { SSXServer } from '@spruceid/ssx-server'

const ssx = new SSXServer()

export default ssx
```

For more information check the [documentation](https://docs.ssx.id/reference/ssx-server).

Second, create an API route for generating a random nonce. This is used to identify the session and prevent against [replay attacks](https://en.wikipedia.org/wiki/Replay_attack).

`ironOptions` should look something like this:

```ts filename="lib/iron.ts"
import type { IronSessionOptions } from 'iron-session'

export const ironOptions: IronSessionOptions = {
  cookieName: 'siwe',
  password: process.env.NEXT_IRON_PASSWORD as string,
  cookieOptions: {
    secure: process.env.NODE_ENV === 'production',
  },
}
```

```ts filename="pages/api/ssx-nonce.ts"
import { withIronSessionApiRoute } from 'iron-session/next'
import type { NextApiRequest, NextApiResponse } from 'next'

import { ironOptions } from '../../lib/iron'
import ssx from './_ssx'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { method } = req
  switch (method) {
    case 'GET':
      req.session.nonce = ssx.generateNonce()
      await req.session.save()
      res.setHeader('Content-Type', 'text/plain')
      res.send(req.session.nonce)
      break
    default:
      res.setHeader('Allow', ['GET'])
      res.status(405).end(`Method ${method} Not Allowed`)
  }
}

export default withIronSessionApiRoute(handler, ironOptions)
```

Next, add an API route for sigining-in a user. That route will also do all the necessary checks in the SIWE message to ensure it's valid. That check occurs inside the `ssx.login()` function.

```ts filename="pages/api/ssx-login.ts"
import { SiweMessage } from '@spruceid/ssx-server'
import { withIronSessionApiRoute } from 'iron-session/next'
import type { NextApiRequest, NextApiResponse } from 'next'

import { ironOptions } from '../../lib/iron'
import ssx from './_ssx'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { method } = req
  switch (method) {
    case 'POST':
      try {
        const { siwe, signature } = req.body
        const siweMessage = new SiweMessage(siwe)
        await ssx.login(
          siwe,
          signature,
          req.body.daoLogin,
          req.body.resolveEns,
          req.cookies.nonce || '',
          req.body.resolveLens,
        )

        req.session.siwe = siweMessage
        await req.session.save()

        res.json({ ok: true })
      } catch (_error) {
        res.json({ ok: false })
      }
      break
    default:
      res.setHeader('Allow', ['POST'])
      res.status(405).end(`Method ${method} Not Allowed`)
  }
}

export default withIronSessionApiRoute(handler, ironOptions)
```

Finally, add two simple API routes for retrieving the signed-in user:

```ts filename="pages/api/me.ts"
import { withIronSessionApiRoute } from 'iron-session/next'
import { NextApiRequest, NextApiResponse } from 'next'

import { ironOptions } from '../../lib/iron'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { method } = req
  switch (method) {
    case 'GET':
      res.send({ address: req.session.siwe?.address })
      break
    default:
      res.setHeader('Allow', ['GET'])
      res.status(405).end(`Method ${method} Not Allowed`)
  }
}

export default withIronSessionApiRoute(handler, ironOptions)
```

And logging out:

```ts filename="pages/api/ssx-logout.ts"
import { withIronSessionApiRoute } from 'iron-session/next'
import type { NextApiRequest, NextApiResponse } from 'next'

import { ironOptions } from '../../lib/iron'
import ssx from './_ssx'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { method } = req
  switch (method) {
    case 'POST':
      await ssx.logout(async () => req.session.destroy())
      res.send({ ok: true })
      break
    default:
      res.setHeader('Allow', ['POST'])
      res.status(405).end(`Method ${method} Not Allowed`)
  }
}

export default withIronSessionApiRoute(handler, ironOptions)
```

## Step 3: Sign & Verify Message

Now that the connect wallet logic and API routes are set up, we can sign in the user! Just setup the `signIn` and `signOut` buttons to call `ssx.signIn` and `ssx.signOut` respectively and you will be good to go.

```tsx filename="components/SSXComponent.tsx"
import * as React from 'react'
import { useAccount, useSigner } from 'wagmi'
import { SSX } from '@spruceid/ssx'

function SignInButton({
  onSuccess,
  onError,
}: {
  onSuccess: (args: { address: string }) => void
  onError: (args: { error: Error }) => void
}) {
  const [state, setState] = React.useState<{
    loading?: boolean
    ssx?: SSX
  }>({})

  const { data: signer } = useSigner()

  // Creates SSX instance once the wallet is connected
  React.useEffect(() => {
    setState((x) => ({
      ...x,
      ssx: new SSX({
        providers: {
          web3: {
            driver: signer?.provider,
          },
          server: {
            host: '/api',
          },
        },
      }),
    }))
  }, [signer])

  const { address } = useAccount()

  const signIn = async () => {
    try {
      setState((x) => ({ ...x, error: undefined, loading: true }))
      if (state.ssx) {
        const res = await state.ssx.signIn()

        setState((x) => ({ ...x, loading: false }))
        onSuccess?.({ address: res.address })
      } else {
        throw new Error('SSX is not initialized.')
      }
    } catch (error) {
      setState((x) => ({ ...x, error: error as Error, loading: false }))
    }
  }

  const signOut = async () => {
    try {
      setState((x) => ({ ...x, error: undefined, loading: true }))
      if (state.ssx) {
        const res = await state.ssx.signOut()
        setState((x) => ({ ...x, loading: false }))
        onSuccess?.({ address: '' })
      } else {
        throw new Error('SSX is not initialized.')
      }
    } catch (error) {
      setState((x) => ({ ...x, error: error as Error, loading: false }))
    }
  }
  if (signer && state.ssx?.address()) {
    return (
      <div>
        <div>Signed in as {address}</div>
        <button onClick={signOut}>Sign Out</button>
      </div>
    )
  }

  return (
    <button disabled={!state.ssx || state.loading} onClick={signIn}>
      Sign-In with SSX
    </button>
  )
}

export function SSXComponent() {
  const { isConnected } = useAccount()

  const [state, setState] = React.useState<{
    address?: string
    error?: Error
    loading?: boolean
  }>({})

  // Fetch user when:
  React.useEffect(() => {
    const handler = async () => {
      try {
        const res = await fetch('/api/me')
        const json = await res.json()
        setState((x) => ({ ...x, address: json.address }))
      } catch (_error) {}
    }
    // 1. page loads
    handler()

    // 2. window is focused (in case user logs out of another window)
    window.addEventListener('focus', handler)
    return () => window.removeEventListener('focus', handler)
  }, [])

  if (isConnected) {
    return (
      <div>
        {/* Account content goes here */}
        <SignInButton
          onSuccess={({ address }) => setState((x) => ({ ...x, address }))}
          onError={({ error }) => setState((x) => ({ ...x, error }))}
        />
      </div>
    )
  }

  return <div>{/* Connect wallet content goes here */}</div>
}

export default SSXComponent
```

## Wrap Up

That's it! You now have a way for users to securely sign in to an app using Ethereum wallets. You can start building rich web apps that use persistent user sessions while still letting users control their login identity (and so much more). Check out the [Sign-In with Ethereum](https://login.xyz) website for more info, and check out the [SSX](https://docs.ssx.id) for more on what else you can do with SIWE.
