---
title: 'Sign-In with Ethereum through SSX Example'
description: 'Learn how to use the SIWE authentication standard with wagmi and SSX.'
---

import { Callout } from 'nextra-theme-docs'

import { SSX } from '../../components/examples'

# Sign-In with Ethereum

[Sign-In with Ethereum](https://login.xyz) is an authentication standard ([EIP-4361](https://docs.login.xyz/general-information/siwe-overview/eip-4361)) that enables secure communication between a frontend and backend. SIWE is a powerful method for creating user sessions based on a wallet connection, and much more!

# SSX

SSX is a library that enables you to easily integrate Sign-In with Ethereum for authenticating users, managing sessions, understanding user metrics, and much more. We've made it simple to add SSX to both your frontend client app, as well your backend server with minimal configuration.

The example below builds on the [Connect Wallet](/examples/connect-wallet) and [Sign Message](/examples/sign-message) examples. Try it out before moving on.

<SSX />

Pretty cool, right?! You can refresh the window or disconnect your wallet, and you are still securely logged in.

## Overview

Implementing SSX only takes four steps:

1. Connect wallet (optional, you can only use the wagmi instance and it'll do it all automatically)
2. Sign SIWE message with nonce generated by backend (all built-in in the `signIn` function)
3. Verify submitted SIWE message and signature via POST request (also built-in in the `login` function of the server)
4. Add validated SIWE fields to session (via JWT, cookie, etc.)

<Callout type="info">
  This guide uses Next.js [API
  Routes](https://nextjs.org/docs/api-routes/introduction) for the backend and
  [`iron-session`](https://github.com/vvo/iron-session) to secure the user
  session, but you can also use other backend frameworks and storage methods.
</Callout>

## Prerequisites

Install [`@spruceid/ssx`](https://www.npmjs.com/package/@spruceid/ssx), [`@spruceid/ssx-server`](https://www.npmjs.com/package/@spruceid/ssx-server) and [`iron-session`](https://github.com/vvo/iron-session) with your package manager of choice:

```plaintext
npm install @spruceid/ssx @spruceid/ssx-server iron-session
```

<details>
  <summary>`iron-session` TypeScript Set Up</summary>
In order for TypeScript to work properly with `iron-session` and `ssx`, you need to add a couple properties to the `IronSessionData` interface. Add the following to `types/iron-session/index.d.ts`.

```ts filename="types/iron-session/index.d.ts"
import 'iron-session'
import { SiweMessage } from '@spruceid/ssx'

declare module 'iron-session' {
  interface IronSessionData {
    nonce?: string
    siwe?: SiweMessage
  }
}
```

Then, update your `tsconfig.json` to include the custom types directory:

```diff filename="tsconfig.json"
{
  "compilerOptions": {
    // ...
  },
-  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
+  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", "types/**/*.d.ts"],
  "exclude": ["node_modules"]
}
```

</details>

## Step 1: Connect Wallet

Follow the [Connect Wallet](/examples/connect-wallet#step-1-configuring-connectors) guide to get this set up.

## Step 2: Add API routes

First let's start by adding a helper file so that we don't have to directly instantiate a new SSX object everytime.

```ts filename="pages/api/_ssx.ts"
import { SSXServer } from '@spruceid/ssx-server'

const ssx = new SSXServer()

export default ssx
```

The above is the minimal setup for SSX Server which has limited functionalities. You can specify a provider to get the full advantage of the server with the following:

```ts filename="pages/api/_ssx.ts"
import {
  SSXInfuraProviderNetworks,
  SSXRPCProviders,
  SSXServer,
} from '@spruceid/ssx-server'

const ssx = new SSXServer({
  providers: {
    rpc: {
      service: SSXRPCProviders.SSXInfuraProvider,
      network:
        process.env.MAINNET === 'false'
          ? SSXInfuraProviderNetworks.GOERLI
          : SSXInfuraProviderNetworks.MAINNET,
      apiKey: process.env.SSX_INFURA_ID ?? '',
    },
  },
})

export default ssx
```

A broad range of providers are supported, for more information check the [documentation](https://docs.ssx.id/reference/ssx-server).

Second, create an API route for generating a random nonce. This is used to identify the session and prevent against [replay attacks](https://en.wikipedia.org/wiki/Replay_attack).

`ironOptions` should look something like this:

```ts filename="lib/iron.ts"
import type { IronSessionOptions } from 'iron-session'

export const ironOptions: IronSessionOptions = {
  cookieName: 'siwe',
  password: process.env.NEXT_IRON_PASSWORD as string,
  cookieOptions: {
    secure: process.env.NODE_ENV === 'production',
  },
}
```

```ts filename="pages/api/ssx-nonce.ts" {11,12}
import { withIronSessionApiRoute } from 'iron-session/next'
import type { NextApiRequest, NextApiResponse } from 'next'

import { ironOptions } from '../../lib/iron'
import ssx from './_ssx'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { method } = req
  switch (method) {
    case 'GET':
      req.session.nonce = ssx.generateNonce()
      await req.session.save()
      res.setHeader('Content-Type', 'text/plain')
      res.send(req.session.nonce)
      break
    default:
      res.setHeader('Allow', ['GET'])
      res.status(405).end(`Method ${method} Not Allowed`)
  }
}

export default withIronSessionApiRoute(handler, ironOptions)
```

Next, add an API route for sigining-in the user, that route will also do all necessary checks in the SIWE message to ensure it's valid, the checks occur inside the `ssx.login()` function.

```ts filename="pages/api/ssx-login.ts" {14-22, 24-25}
import { SiweMessage } from '@spruceid/ssx-server'
import { withIronSessionApiRoute } from 'iron-session/next'
import type { NextApiRequest, NextApiResponse } from 'next'

import { ironOptions } from '../../lib/iron'
import ssx from './_ssx'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { method } = req
  switch (method) {
    case 'POST':
      try {
        const { siwe, signature } = req.body
        const siweMessage = new SiweMessage(siwe)
        await ssx.login(
          siwe,
          signature,
          req.body.daoLogin,
          req.body.resolveEns,
          req.cookies.nonce || '',
          req.body.resolveLens,
        )

        req.session.siwe = siweMessage
        await req.session.save()

        res.json({ ok: true })
      } catch (_error) {
        res.json({ ok: false })
      }
      break
    default:
      res.setHeader('Allow', ['POST'])
      res.status(405).end(`Method ${method} Not Allowed`)
  }
}

export default withIronSessionApiRoute(handler, ironOptions)
```

Finally, add two simple API routes for retrieving the signed-in user:

```ts filename="pages/api/me.ts"
import { withIronSessionApiRoute } from 'iron-session/next'
import { NextApiRequest, NextApiResponse } from 'next'

import { ironOptions } from '../../lib/iron'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { method } = req
  switch (method) {
    case 'GET':
      res.send({ address: req.session.siwe?.address })
      break
    default:
      res.setHeader('Allow', ['GET'])
      res.status(405).end(`Method ${method} Not Allowed`)
  }
}

export default withIronSessionApiRoute(handler, ironOptions)
```

And logging out:

```ts filename="pages/api/ssx-logout.ts"
import { withIronSessionApiRoute } from 'iron-session/next'
import type { NextApiRequest, NextApiResponse } from 'next'

import { ironOptions } from '../../lib/iron'
import ssx from './_ssx'

const handler = async (req: NextApiRequest, res: NextApiResponse) => {
  const { method } = req
  switch (method) {
    case 'POST':
      await ssx.logout(async () => req.session.destroy())
      res.send({ ok: true })
      break
    default:
      res.setHeader('Allow', ['POST'])
      res.status(405).end(`Method ${method} Not Allowed`)
  }
}

export default withIronSessionApiRoute(handler, ironOptions)
```

## Step 3: Sign & Verify Message

Now that the connect wallet logic and API routes are set up, we can sign in the user! Just setup the signIn and signOut buttons to call `ssx.signIn` and `ssx.signOut` respectively and you will be good to go.

```tsx filename="components/SSXComponent.tsx"
import * as React from 'react'
import { useAccount, useSigner } from 'wagmi'
import { SSX } from '@spruceid/ssx'

function SignInButton({
  onSuccess,
  onError,
}: {
  onSuccess: (args: { address: string }) => void
  onError: (args: { error: Error }) => void
}) {
  const [state, setState] = React.useState<{
    loading?: boolean
    ssx?: SSX
  }>({})

  const { data: signer } = useSigner()

  // Creates SSX instance once the wallet is connected
  React.useEffect(() => {
    setState((x) => ({
      ...x,
      ssx: new SSX({
        providers: {
          web3: {
            driver: signer?.provider,
          },
          server: {
            host: '/api',
          },
        },
      }),
    }))
  }, [signer])

  const { address } = useAccount()

  const signIn = async () => {
    try {
      setState((x) => ({ ...x, error: undefined, loading: true }))
      if (state.ssx) {
        const res = await state.ssx.signIn()

        setState((x) => ({ ...x, loading: false }))
        onSuccess?.({ address: res.address })
      } else {
        throw new Error('SSX is not initialized.')
      }
    } catch (error) {
      setState((x) => ({ ...x, error: error as Error, loading: false }))
    }
  }

  const signOut = async () => {
    try {
      setState((x) => ({ ...x, error: undefined, loading: true }))
      if (state.ssx) {
        const res = await state.ssx.signOut()
        setState((x) => ({ ...x, loading: false }))
        onSuccess?.({ address: '' })
      } else {
        throw new Error('SSX is not initialized.')
      }
    } catch (error) {
      setState((x) => ({ ...x, error: error as Error, loading: false }))
    }
  }
  if (signer && state.ssx?.address()) {
    return (
      <div>
        <div>Signed in as {address}</div>
        <button onClick={signOut}>Sign Out</button>
      </div>
    )
  }

  return (
    <button disabled={!state.ssx || state.loading} onClick={signIn}>
      Sign-In with SSX
    </button>
  )
}

export function SSXComponent() {
  const { isConnected } = useAccount()

  const [state, setState] = React.useState<{
    address?: string
    error?: Error
    loading?: boolean
  }>({})

  // Fetch user when:
  React.useEffect(() => {
    const handler = async () => {
      try {
        const res = await fetch('/api/me')
        const json = await res.json()
        setState((x) => ({ ...x, address: json.address }))
      } catch (_error) {}
    }
    // 1. page loads
    handler()

    // 2. window is focused (in case user logs out of another window)
    window.addEventListener('focus', handler)
    return () => window.removeEventListener('focus', handler)
  }, [])

  if (isConnected) {
    return (
      <div>
        {/* Account content goes here */}
        <SignInButton
          onSuccess={({ address }) => setState((x) => ({ ...x, address }))}
          onError={({ error }) => setState((x) => ({ ...x, error }))}
        />
      </div>
    )
  }

  return <div>{/* Connect wallet content goes here */}</div>
}

export default SSXComponent
```

## Wrap Up

That's it! You now have a way for users to securely sign in to an app using Ethereum wallets. You can start building rich web apps that use persistent user sessions while still letting users control their login identity (and so much more). Check out the [SSX](https://docs.ssx.id) website for more info.
